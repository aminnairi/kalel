import { Document } from "./jorel/Document";

/**
 * Whenever a validation is a success
 */
export interface ValidationSuccess<GenericSchema extends Schema> {
  /**
   * The state of this validation used for type discriminiation, in case of a success, this is always true
   */
  success: true,
  /**
   * The data associated with the validation
   */
  data: InferType<GenericSchema>
}

/**
 * The details of an error returned by a validation
 */
export interface ValidationError {
  /**
   * The path to the property or index that introduce this error
   */
  path: string,
  /**
   * The error message associated with this error
   */
  message: string
}

/**
 * The list of errors generated when an error occurs
 */
export interface ValidationErrors {
  /**
   * The state of this validation used for type discriminiation, in case of an error, this is always false
   */
  success: false,
  /**
   * The list of errors generated by this validation
   */
  errors: Array<ValidationError>
}

/**
 * Whether the validation is a success or a failure, you have to use type discrimination in order to get the correct type
 */
export type Validation<GenericSchema extends Schema> = ValidationSuccess<GenericSchema> | ValidationErrors

/**
 * The type of the rule that is applied for a given type
 */
export interface Rule<Value> {
  /**
   * The validation function that returns a boolean whenever the data validated is correct according to the validation function's algorithm
   */
  valid: (value: Value) => boolean,
  /**
   * The message to attach to the generated error whenever the valiation fucntions does not return a true value
   */
  message: string
}

/**
 * The rule definition for a string
 */
export type StringRule = Rule<string>

/**
 * The rule definition for a number
 */
export type NumberRule = Rule<number>

/**
 * The rule definition for an array
 */
export type ArrayRule = Rule<Array<unknown>>

/**
 * The rule definition for a date
 */
export type DateRule = Rule<Date>

/**
 * The rule definition for a string
 */
export type StringRules = Array<StringRule>

/**
 * An array of rules for validating numbers
 */
export type NumberRules = Array<NumberRule>

/**
 * An array of rules for validating arrays
 */
export type ArrayRules = Array<ArrayRule>

/**
 * An array of rules for validating dates
 */
export type DateRules = Array<DateRule>

/**
 * The schema definition used for validating strings
 */
export interface StringSchema {
  /**
   * The type of the schema that is used for validating strings
   */
  type: "string",
  /**
   * The message attached to the error
   */
  message: string,
  /**
   * A list of rules to apply to the string being validated
   */
  rules: StringRules
}

/**
 * The schema definition used for validating numbers
 */
export interface NumberSchema {
  /**
   * The type of the schema that is used for validating numbers
   */
  type: "number",
  /**
   * The message attached to the error
   */
  message: string,
  /**
   * A list of rules to apply to the number being validated
   */
  rules: NumberRules
}

/**
 * The schema definition used for validating arrays
 */
export interface ArraySchema<GenericSchema extends Schema> {
  /**
   * The type of the schema that is used for validating arrays
   */
  type: "array",
  /**
   * The message attached to the error
   */
  message: string,
  /**
   * The schema used for the type of the elements inside the array being validated
   */
  schema: GenericSchema,
  /**
   * A list of rules to apply to the array being validated
   */
  rules: ArrayRules
}

/**
 * The fields inside the object being validated, each with a property name and a schema
 */
export type ObjectSchemaFields<GenericSchema extends Schema> = Record<string, GenericSchema>

/**
 * The schema definition used for validating objects
 */
export interface ObjectSchema<Fields extends ObjectSchemaFields<Schema>> {
  /**
   * The type of the schema that is used for validating objects
   */
  type: "object",
  /**
   * The message attached to the error
   */
  message: string,
  /**
   * An object containing all the properties along with their schema
   */
  fields: Fields
}

/**
 * The schema definition used for any values
 */
export interface AnySchema {
  /**
   * The type of the schema that is used for validating anything
   */
  type: "any"
}

/**
 * The schema definition used for any unknown values
 */
export interface UnknownSchema {
  /**
   * The type of the schema that is used for validating unknown values
   */
  type: "unknown"
}

/**
 * The schema definition used for any unknown booleans
 */
export interface BooleanSchema {
  /**
   * The type of the schema that is used for validating booleans
   */
  type: "boolean",
  /**
   * The message attached to the error
   */
  message: string
}

/**
 * The schema definition used for null values
 */
export interface NoneSchema {
  /**
   * The type of the schema that is used for validating null values
   */
  type: "none",
  /**
   * The message attached to the error
   */
  message: string
}

/**
 * The schema definition used for null values
 */
export interface NotDefinedSchema {
  /**
   * The type of the schema that is used for validating undefined values
   */
  type: "notDefined",
  /**
   * The message attached to the error
   */
  message: string
}

/**
 * The schema definition used for void values
 */
export interface EmptySchema {
  /**
   * The type of the schema that is used for validating void values
   */
  type: "empty",
  /**
   * The message attached to the error
   */
  message: string
}

/**
 * The schema definition used for date values
 */
export interface DateSchema {
  /**
   * The type of the schema that is used for validating date values
   */
  type: "date",
  /**
   * A list of rules to apply to the date being validated
   */
  rules: DateRules,
  /**
   * The message attached to the error
   */
  message: string
}

/**
 * The schema definition used for literal values
 */
export interface LiteralSchema<Value> {
  /**
   * The type of the schema that is used for validating literal values
   */
  type: "literal",
  /**
   * The message attached to the error
   */
  message: string,
  /**
   * The literal value's type, this should be used with the keyword "as const"
   */
  value: Value
}

/**
 * The type of the schema that is used for validating union values
 */
export interface OneOfSchema<GenericSchema extends Schema> {
  /**
   * The type of the schema that is used for validating union values
   */
  type: "oneOf",
  /**
   * The schema used for the type of the elements in the union being validated
   */
  schema: Array<GenericSchema>
}

export interface DocumentSchema {
  type: "document",
  message: string
}

/**
 * A union of types that can be primitives schemas, meanining concrete types like strings or booleans
 */
export type BasicSchema =
  | UnknownSchema
  | AnySchema
  | StringSchema
  | NumberSchema
  | BooleanSchema
  | NoneSchema
  | NotDefinedSchema
  | EmptySchema
  | DateSchema
  | DocumentSchema
  | ArraySchema<Schema>
  | ObjectSchema<ObjectSchemaFields<Schema>>
  | LiteralSchema<unknown>

/**
 * A union of types that are not concrete types but more constraints about what the type can be
 */
export type ConstraintSchema =
  | OneOfSchema<BasicSchema>

/**
 * A union of all schemas merged altogether
 */
export type Schema =
  | BasicSchema
  | ConstraintSchema

/**
 * A utility type that can infer the type of a value based on its schema for basic schemas
 */
export type InferBasicType<GenericBasicSchema extends BasicSchema> =
  GenericBasicSchema extends AnySchema
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  ? any
  : GenericBasicSchema extends UnknownSchema
  ? unknown
  : GenericBasicSchema extends NumberSchema
  ? number
  : GenericBasicSchema extends StringSchema
  ? string
  : GenericBasicSchema extends BooleanSchema
  ? boolean
  : GenericBasicSchema extends DateSchema
  ? Date
  : GenericBasicSchema extends NoneSchema
  ? null
  : GenericBasicSchema extends NotDefinedSchema
  ? undefined
  : GenericBasicSchema extends EmptySchema
  ? void
  : GenericBasicSchema extends LiteralSchema<infer InferedType>
  ? InferedType
  : GenericBasicSchema extends DocumentSchema
  ? Document
  : GenericBasicSchema extends ArraySchema<infer InferedSchema extends Schema>
  ? Array<InferType<InferedSchema>>
  : GenericBasicSchema extends ObjectSchema<infer Fields>
  ? { [FieldKey in keyof Fields]: InferType<Fields[FieldKey]> }
  : never;

/**
 * A utility type that can infer the type of a value based on its schema for constraints schemas
 */
export type InferConstraintType<GenericConstraintSchema extends ConstraintSchema> =
  GenericConstraintSchema extends OneOfSchema<infer InferedSchema extends BasicSchema>
  ? InferBasicType<InferedSchema>
  : never

/**
 * A utility type that can infer the type of a value based on its schema
 */
export type InferType<GenericSchema extends Schema> =
  GenericSchema extends BasicSchema
  ? InferBasicType<GenericSchema>
  : GenericSchema extends ConstraintSchema
  ? InferConstraintType<GenericSchema>
  : never

/**
 * A function that can accept any values, and that returns a valiation, either a success or a failure and you have to use type discrimination in order to get the correct infered type out of this validation result
 */
export type Validator<GenericSchema extends Schema> = (data: unknown) => Validation<GenericSchema>

/**
 * Options for the string schema function
 */
export interface StringOptions {
  /**
   * The message attached to the error
   */
  message: string,
  /**
   * A list of rules to apply to the string being validated
   */
  rules: StringRules
}

/**
 * Create a schema to validate strings
 */
export const string = ({ message, rules }: StringOptions): StringSchema => {
  return {
    type: "string",
    message,
    rules
  };
};

/**
 * Options for the number schema function
 */
export interface NumberOptions {
  /**
   * The error message to attach
   */
  message: string,
  /**
   * A list of rules to apply to the number being validated
   */
  rules: NumberRules
}

/**
 * Create a schema to validate numbers
 */
export const number = ({ message, rules }: NumberOptions): NumberSchema => {
  return {
    type: "number",
    message,
    rules
  };
};

/**
 * Options for the array schema function
 */
export interface ArrayOptions<GenericSchema extends Schema> {
  /**
   * The schema to use for each item in the array
   */
  schema: GenericSchema,
  /**
   * The message to attach to the error
   */
  message: string,
  /**
   * A list of rules to apply to the array being validated
   */
  rules: ArrayRules
}

/**
 * Create a schema to validate arrays
 */
export const array = <GenericSchema extends Schema>({ schema, message, rules }: ArrayOptions<GenericSchema>): ArraySchema<GenericSchema> => {
  return {
    type: "array",
    schema,
    message,
    rules
  };
};

/**
 * Options for the object schema function
 */
export interface ObjectOptions<GenericSchema extends Schema, GenericObjectSchemaFields extends ObjectSchemaFields<GenericSchema>> {
  /**
   * The fields along with their schema
   */
  fields: GenericObjectSchemaFields,
  /**
   * The message to attach to the error
   */
  message: string,
}

/**
 * Create a schema to validate object
 */
export const object = <GenericSchema extends Schema, GenericObjectSchemaFields extends ObjectSchemaFields<GenericSchema>>({ fields, message }: ObjectOptions<GenericSchema, GenericObjectSchemaFields>): ObjectSchema<GenericObjectSchemaFields> => {
  return {
    type: "object",
    fields,
    message,
  };
};

/**
 * Options for the date schema function
 */
export interface DateOptions {
  /**
   * Message attached to the error
   */
  message: string,
  /**
   * Rules to apply to the date to validate
   */
  rules: DateRules
}

/**
 * Create a schema to validate a date
 */
export const date = ({ message, rules }: DateOptions): DateSchema => {
  return {
    type: "date",
    rules,
    message
  };
};

/**
 * Create a schema to validate data to any
 */
export const any = (): AnySchema => {
  return {
    type: "any"
  };
};

/**
 * Create a schema to validate data to unknown
 */
export const unknown = (): UnknownSchema => {
  return {
    type: "unknown"
  };
};

/**
 * Options for the boolean schema function
 */
export interface BooleanOptions {
  /**
   * The message attached to the error
   */
  message: string
}

/**
 * Create a schema to validate boolean values
 */
export const boolean = ({ message }: BooleanOptions): BooleanSchema => {
  return {
    type: "boolean",
    message
  };
};

/**
 * Options for the none schema function
 */
export interface NoneOptions {
  /**
   * The message attached to the error
   */
  message: string
}

/**
 * Create a schema to validate null values
 */
export const none = ({ message }: NoneOptions): NoneSchema => {
  return {
    type: "none",
    message
  };
};

/**
 * Options for the notDefined schema function
 */
export interface NotDefinedOptions {
  /***
   * The message attached to the error
   */
  message: string
}

/**
 * Create a schema to validate undefined values
 */
export const notDefined = ({ message }: NotDefinedOptions): NotDefinedSchema => {
  return {
    type: "notDefined",
    message
  };
};

/**
 * Options for the empty schema function
 */
export interface EmptyOptions {
  /**
   * The message attached to the error
   */
  message: string
}

/**
 * Create a schema to validate void values
 */
export const empty = ({ message }: EmptyOptions): EmptySchema => {
  return {
    type: "empty",
    message
  };
};

/**
 * Options for the literal schema function
 */
export interface LiteralOptions<Value> {
  /**
   * Message attached to the error
   */
  message: string,
  /**
   * The literal value to validate
   */
  value: Value
}

/**
 * Create a schema to validate any literal value
 */
export const literal = <Value>({ message, value }: LiteralOptions<Value>): LiteralSchema<Value> => {
  return {
    type: "literal",
    message,
    value
  };
};

/**
 * Create a schema to validate a union of values
 */
export const oneOf = <GenericSchema extends Schema>(schema: Array<GenericSchema>): OneOfSchema<GenericSchema> => {
  return {
    type: "oneOf",
    schema: schema
  };
};

export interface DocumentOptions {
  message: string
}

export const document = ({ message }: DocumentOptions): DocumentSchema => {
  return {
    type: "document",
    message
  };
};

/**
 * Create a validator function to validate data
 * @param schema The schema to apply for validation
 * @param initialPath The initial path (used internally for recursivity)
 */
export const createProtector = <GenericSchema extends Schema>(schema: GenericSchema, initialPath: string = ""): Validator<GenericSchema> => {
  return data => {
    if (schema.type === "document") {
      if (data instanceof Document) {
        return {
          success: true,
          data: data as InferType<GenericSchema>
        };
      }

      if (typeof data === "object" && data !== null && "bytes" in data && "name" in data && "mimeType" in data && typeof data.bytes === "string" && typeof data.name === "string" && typeof data.mimeType === "string") {
        const document = new Document(data.bytes, data.name, data.mimeType) as InferType<GenericSchema>;

        return {
          success: true,
          data: document
        };
      }

      return {
        success: false,
        errors: [
          {
            path: initialPath,
            message: schema.message
          }
        ]
      };
    }

    if (schema.type === "oneOf") {
      const validations = schema.schema.map(validation => {
        const protect = createProtector(validation);
        const protection = protect(data);

        return protection;
      });

      const isValidationSuccess = (validation: Validation<GenericSchema>): validation is ValidationSuccess<GenericSchema> => {
        return validation.success;
      };

      const validationSuccesses = validations.filter(isValidationSuccess);

      if (validationSuccesses.length !== 0) {
        const validationSuccess = validationSuccesses[0] as ValidationSuccess<GenericSchema>;

        return {
          success: true,
          data: validationSuccess.data
        };
      }

      const isValidationFailure = (validation: Validation<GenericSchema>): validation is ValidationErrors => {
        return !validation.success;
      };

      const validationFailures = validations.filter(isValidationFailure);

      return {
        success: false,
        errors: validationFailures.flatMap(validation => {
          return validation.errors;
        })
      };
    }

    if (schema.type === "literal") {
      if (schema.value !== data) {
        return {
          success: false,
          errors: [
            {
              path: initialPath,
              message: schema.message
            }
          ]
        };
      }

      return {
        success: true,
        data: data as InferType<GenericSchema>
      };
    }

    if (schema.type === "empty") {
      if (typeof data !== "undefined") {
        return {
          success: false,
          errors: [
            {
              path: initialPath,
              message: schema.message
            }
          ]
        };
      }

      return {
        success: true,
        data: data as InferType<GenericSchema>
      };
    }

    if (schema.type === "boolean") {
      if (typeof data !== "boolean") {
        return {
          success: false,
          errors: [
            {
              path: initialPath,
              message: schema.message
            }
          ]
        };
      }

      return {
        success: true,
        data: data as InferType<GenericSchema>
      };
    }

    if (schema.type === "unknown") {
      return {
        success: true,
        data: data as InferType<GenericSchema>
      };
    }

    if (schema.type === "none") {
      if (data !== null) {
        return {
          success: false,
          errors: [
            {
              path: initialPath,
              message: schema.message
            }
          ]
        };
      }

      return {
        success: true,
        data: data as InferType<GenericSchema>
      };
    }

    if (schema.type === "notDefined") {
      if (data !== undefined) {
        return {
          success: false,
          errors: [
            {
              path: initialPath,
              message: schema.message
            }
          ]
        };
      }

      return {
        success: true,
        data: data as InferType<GenericSchema>
      };
    }

    if (schema.type === "any") {
      return {
        success: true,
        data: data as InferType<GenericSchema>
      };
    }

    if (schema.type === "date") {
      const date = new Date(String(data));

      if (Number.isNaN(date.getTime())) {
        return {
          success: false,
          errors: [
            {
              path: initialPath,
              message: schema.message
            }
          ]
        };
      }

      const initialErrors: Array<ValidationError> = [];

      const errors = schema.rules.reduce((previousErrors, rule) => {
        if (!rule.valid(date)) {
          return [
            ...previousErrors,
            {
              path: initialPath,
              message: rule.message
            }
          ];
        }

        return previousErrors;
      }, initialErrors);

      if (errors.length !== 0) {
        return {
          success: false,
          errors
        };
      }

      return {
        success: true,
        data: date as InferType<GenericSchema>
      };
    }

    if (schema.type === "number") {
      if (typeof data !== "number") {
        return {
          success: false,
          errors: [
            {
              path: initialPath,
              message: schema.message
            }
          ]
        };
      }

      const initialErrors: Array<ValidationError> = [];

      const errors = schema.rules.reduce((previousErrors, rule) => {
        if (!rule.valid(data)) {
          return [
            ...previousErrors,
            {
              path: initialPath,
              message: rule.message
            }
          ];
        }

        return previousErrors;
      }, initialErrors);

      if (errors.length !== 0) {
        return {
          success: false,
          errors
        };
      }

      return {
        success: true,
        data: data as InferType<GenericSchema>
      };
    }

    if (schema.type === "string") {
      if (typeof data === "string") {
        const initialErrors: Array<ValidationError> = [];

        const errors = schema.rules.reduce((previousErrors, rule) => {
          if (!rule.valid(data)) {
            return [
              ...previousErrors,
              {
                path: initialPath,
                message: rule.message
              }
            ];
          }

          return previousErrors;
        }, initialErrors);

        if (errors.length !== 0) {
          return {
            success: false,
            errors
          };
        }

        return {
          success: true,
          data: data as InferType<GenericSchema>
        };
      }

      return {
        success: false,
        errors: [
          {
            path: initialPath,
            message: schema.message
          }
        ]
      };
    }

    if (schema.type === "array") {
      if (!Array.isArray(data)) {
        return {
          success: false,
          errors: [
            {
              path: initialPath,
              message: schema.message
            }
          ]
        };
      }

      const initialErrors: Array<ValidationError> = [];

      const errors = schema.rules.reduce((previousErrors, rule) => {
        if (!rule.valid(data)) {
          return [
            ...previousErrors,
            {
              path: initialPath,
              message: rule.message
            }
          ];
        }

        return previousErrors;
      }, initialErrors);

      if (errors.length !== 0) {
        return {
          success: false,
          errors
        };
      }

      const itemValidations = data.map((item, itemIndex) => {
        const validateArrayItem = createProtector(schema.schema, `${initialPath}[${itemIndex}]`);
        const itemValidation = validateArrayItem(item);

        return itemValidation;
      });

      const itemValidationErrors = itemValidations.flatMap(itemValidation => {
        if (itemValidation.success) {
          return null;
        }

        return itemValidation.errors;
      }).filter(itemValidation => {
        return itemValidation !== null;
      }) as Array<ValidationError>;

      const itemValidationData = itemValidations.map(itemValidation => {
        if (!itemValidation.success) {
          return null;
        }

        return itemValidation.data;
      }).filter(itemValidation => {
        return itemValidation !== null;
      }) as InferType<GenericSchema>;

      if (itemValidationErrors.length !== 0) {
        return {
          success: false,
          errors: itemValidationErrors
        };
      }

      return {
        success: true,
        data: itemValidationData
      };
    }

    if (schema.type === "object") {
      if (typeof data !== "object" || data === null || Array.isArray(data)) {
        return {
          success: false,
          errors: [
            {
              path: initialPath,
              message: schema.message
            }
          ]
        };
      }

      const validations = Object.entries(schema.fields).map(([fieldName, schema]) => {
        const validateObjectField = createProtector(schema, `${initialPath}.${fieldName}`);
        const fieldData = (data as Record<string, unknown>)[fieldName];
        const fieldValidation = validateObjectField(fieldData);

        return [
          fieldName,
          fieldValidation
        ];
      }) as Array<[string, Validation<GenericSchema>]>;

      const validationErrors = validations.flatMap(([, validation]) => {
        if (validation.success) {
          return null;
        }

        return validation.errors;
      }).filter(validationErrors => {
        return validationErrors !== null;
      }) as Array<ValidationError>;

      const validationEntries = validations.map(([field, validation]) => {
        if (!validation.success) {
          return null;
        }

        return [
          field,
          validation.data
        ];
      }).filter(validationEntry => {
        return validationEntry !== null;
      }) as Array<[string, InferType<GenericSchema>]>;

      const validationData = Object.fromEntries(validationEntries) as InferType<GenericSchema>;

      if (validationErrors.length !== 0) {
        return {
          success: false,
          errors: validationErrors
        };
      }

      return {
        success: true,
        data: validationData
      };
    }

    return {
      success: false,
      errors: [
        {
          path: initialPath,
          message: "Unknown type"
        }
      ]
    };
  };
};

export * as Array from "./kalel/array";
export * as Number from "./kalel/number";
export * as String from "./kalel/string";
export * as Date from "./kalel/date";
